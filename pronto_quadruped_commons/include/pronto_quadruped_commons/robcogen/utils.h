/*
 * Copyright (c) 2015-2018, Marco Frigerio
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#include <iostream>
#include <ctime>

#include "pronto_quadruped_commons/rbd/rbd.h"

namespace pronto {
/**
 * This namespace contains some facilities related to the C++ code generated by
 * the Robotics Code Generator (RobCoGen).
 *
 * Nothing in this namespace is required to *compile* nor to *use* the
 * kinematics/dynamics engines generated by RobCoGen in one's application.
 * Think of this namespace as a container for bonus material, such as functions
 * to test the generated C++.
 */
namespace robcogen {

/**
 * Utilities to be used with the C++ code generated by RobCoGen
 */
namespace utils {


template <class RT>
void cmdlineargs_jstate(int argc, char** argv, typename RT::JointState& state)
{
    if(argc < RT::joints_count) {
        std::cerr << "Not enough arguments" << std::endl;
        exit(-1);
    }
    for(int i=0; i<RT::joints_count; i++) {
        state(i) = std::atof(argv[i]);
    }
}

template <class RT>
void cmdlineargs_jstate(int argc, char** argv,
        typename RT::JointState& state1,
        typename RT::JointState& state2)
{
    if(argc < 2*RT::joints_count) {
        std::cerr << "Not enough arguments" << std::endl;
        exit(-1);
    }
    for(int i=0; i<RT::joints_count; i++) {
        state1(i) = std::atof(argv[i]);
        state2(i) = std::atof(argv[RT::joints_count+i]);
    }
}

template <class RT>
void cmdlineargs_jstate(int argc, char** argv,
        typename RT::JointState& state1,
        typename RT::JointState& state2,
        typename RT::JointState& state3)
{
    if(argc < 3*RT::joints_count) {
        std::cerr << "Not enough arguments" << std::endl;
        exit(-1);
    }
    for(int i=0; i<RT::joints_count; i++) {
        state1(i) = std::atof(argv[i]);
        state2(i) = std::atof(argv[i+RT::joints_count]);
        state3(i) = std::atof(argv[i+2*RT::joints_count]);
    }
}


template <class RT>
void rand_jstate(typename RT::JointState& state)
{
    std::srand(std::time(NULL));
    for(int i=0; i<RT::joints_count; i++) {
        state(i) = ((double)std::rand()) / RAND_MAX;
    }
}

/**
 * Random initialization of three joint-status vectors.
 * \tparam RT the Traits class of the robot, as generated by RobCoGen
 */
template <class RT>
void rand_jstate(
    typename RT::JointState& q,
    typename RT::JointState& qd,
    typename RT::JointState& qdd)
{
    std::srand(std::time(NULL));
    for(int i=0; i<RT::joints_count; i++) {
        q(i)   = ((double)std::rand()) / RAND_MAX;
        qd(i)  = ((double)std::rand()) / RAND_MAX;
        qdd(i) = ((double)std::rand()) / RAND_MAX;
    }
}



}
}
}
